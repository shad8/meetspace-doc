\section{Testy}
  \label{testy}
  Wzrost wymagań klientów sprawia, iż technologie internetowe rozwijają się bardzo szybko. Wiele firm kładzie duży nacisk na testowanie swoich aplikacji.

  Programiści często wychodzą z założenia, że ,,najpierw kod, później testy". Ma to oczywiście swoje wady i zalety. Zaletą niewątpliwie jest czas realizacji. W pierwszej kolejności dostarcza się funkcjonalności i nie zastanawia się nad tym jak napisać do nich testy. Pod koniec procesu produkcji tworzy się kilka testów sprawdzających zachowanie aplikacji. Doprowadza to do tego, że cały kod aplikacji pokryty jest testami w bardzo niewielkim stopniu. W każdej chwili może zajść sytuacja, w której aplikacja przestanie działać zgodnie z założeniami. Niestety w takim przypadku tracimy cenne godziny na szukanie błędów i ich eliminację.

  Podczas tworzenia aplikacji Meetspace przyjęliśmy zupełnie inne podejście - „najpierw testy, później kod". Czas pisania aplikacji znacznie się wydłużył. Osiągnęliśmy jednak bardzo dobre pokrycie kodu testami.

  Dzięki napisanym testom oszczędziliśmy sporo godzin przy diagnozowaniu błędów aplikacji. Kolejną zaletą obranego podejścia jest to, że napisany w ten sposób przez nas kod robi dokładnie to czego oczekujemy. Każdy test spełniany jest w najprostszy możliwy sposób. Na jedną metodę przypada kilka lub nawet kilkanaście testów. Jeżeli któryś z nich się nie spełni, wiadomo od razu gdzie szukać przyczyny.

  \subsection{Techniki tworzenia oprogramowania}
    Techniki tworzenia oprogramowania są niezwykle ważne w całym procesie powstawania kodu. Pomagają efektywnie zarządzać zasobami zespołu, czasem, zadaniami i celami, które stoją przed zespołem.

    Poniżej krótko objaśniliśmy te techniki, z których korzystaliśmy.
    \index{TDD}
    \begin{itemize}
      \item \textbf{Test Driven Development}\cite{tdd} \\
        Technika tworzenia oprogramowania, sterowana przez testy. Polega na powtarzaniu 3 kroków do momentu ukończenia funkcjonalności:
        \begin{enumerate}
          \item Napisanie możliwie najprostszego testu jednostkowego, który ma sprawdzać kod pisany w kroku 2. Test po napisaniu powinien zostać od razu uruchomiony. Nowy test musi dać wynik negatywny, gdyż dopiero będziemy dodawać testowaną funkcjonalność. Otrzymanie pozytywnego wyniku świadczy o obecności w aplikacji funkcjonalności - test jest niepotrzebny lub źle skonstruowany.
          \item Implementacja kodu. Kod powinien być napisany w taki sposób, aby spełnić założenia testu, nic ponad to. Test powinien zakończyć się sukcesem i nie naruszać pozostałych testów.
          \item Refaktoryzacja. Doprowadzenie kodu do stanu, w którym spełnia przyjęte normy i standardy prostego oraz czytelnego kodu\cite{scs}. Ponad to wszystkie testy w aplikacji powinny się spełniać.
        \end{enumerate}

        Postępowanie według tego schematu, zmusza programistę do wcześniejszego przemyślenia funkcjonalności, którą ma napisać.

        Wady:
        \begin{itemize}
          \item Wydłuża się czas pisania aplikacji, zwłaszcza w początkowej fazie wdrażania tej techniki. Jednak wraz z ilością napisanych testów jednostkowych rośnie wydajność ich pisania.
          \item Wraz z rozwojem aplikacji rośnie również ilość testów. Dopóki funkcjonalności są dopisywane, problem nie istnieje. Zmiana funkcjonalności narzuca zmiany po stronie istniejących do niej testów.
        \end{itemize}

        Zalety:
        \begin{itemize}
          \item Główną zaletą tej metodologii jest szybkość diagnozowania błędów. Dzięki temu oszczędzamy czas. Bez testów musielibyśmy poświęcić go na dogłębną analizę kodu.
          \item Jeżeli testy są pisane w czytelny sposób, mogą stanowić bardzo dobrą dokumentację. Wystarczy zajrzeć do testu i widać czego programista oczekiwał od konkretnej metody.
          \item Bardziej przemyślany kod. W pierwszej kolejności musimy się zastanowić co tak naprawdę ma zawierać dana funkcjonalność, żeby móc od niej to wyegzekwować.
          \item Zapewnienie minimalnej ilości kodu dla danej funkcjonalności.
        \end{itemize}

        \begin{figure}[h]
          \centering
          \includegraphics[scale=0.47]{images/test_cycle.png}
          \caption{Schemat postępowania w TDD}
        \end{figure}

      \newpage
      \index{BDD}
      \item \textbf{Behaviour Driven Development} \\
        Technika stworzona przez Dana Northa w 2003 roku. Sam autor powiedział:
        \begin{quote}
          \emph{„Behaviour-driven Development polega na tworzeniu oprogramowania przez opisywanie jego zachowania, z perspektywy jego udziałowców.”}
        \end{quote}

        Dzięki takiej metodyce testowania, programiści wychodzą naprzeciw klientowi, starają się go zrozumieć i spełnić jego wymagania.

        Oczekiwania klienta są zapisywane w postaci krótkich historyjek, scenariuszy.
        Podczas ich tworzenia korzysta się z trzech głównych słów kluczowych:
          \begin{itemize}
            \item \textbf{Podane (\emph{Given})} - opisuje stan początkowy aplikacji.
            \item \textbf{Kiedy (\emph{When})} - wszystkie kroki jakie klient/użytkownik musi wykonać aby osiągnąć funkcjonalność.
            \item \textbf{Wtedy (\emph{Then})} - stan końcowy aplikacji, czyli oczekiwany efekt po przejściu przez wcześniejsze kroki.
          \end{itemize}

        \emph{Test driven development} to testowanie na poziomie kodu, które stanowią część BDD. Stosując również ten element mamy pewność, że konkretna funkcjonalność jest należycie przetestowana i~ spełnia oczekiwania oraz wymogi klienta.
    \end{itemize}

  \subsection{Testy integracyjne}
    \index{Cucumber}
    Najważniejszą funkcjonalnością w naszej aplikacji jest kreowanie nowego wydarzenia. Poniżej przedstawimy proces tworzenia testu integracyjnego za pomocą narzędzia \emph{Cucumber}.

    \input{source_codes/cucumber}
  \subsection{Testy jednostkowe}
    \index{RSpec}
    Testy jednostkowe weryfikują działanie pojedynczych elementów(jednostek) programu, poszczególnych metod czy relacji między obiektami. Taki test wykonuje dany fragment kodu i porównuje otrzymane wyniki z tymi oczekiwanymi. Każdy z testów jest wykonywany w osobnym, odizolowanym środowisku, dzięki czemu jest niezależny i nie wpływa na pozostałe.

    \input{source_codes/rspec}
  \clearpage
  \subsection{Pokrycie kodu testami}
    Dzięki zastosowaniu technologi Ruby on Rails, mieliśmy do dyspozycji wiele przydatnych narzędzi pozwalających sprawdzać jakość tworzonego kodu. Jednym z~ nich jest \emph{Stats}, który wykazuje pokrycie kodu testami.

    Statystyka wyliczana jest na podstawie ilości lini kodu (LOC - lines of code) do ilości lini testów (LOT - lines of test). Oczekiwanym wynikiem powinien być stosunek 1:2, który udało nam się osiągnąć, co przedstawia rysunek nr \ref{fig:stat}.
    \begin{figure}[h]
      \centering
      \includegraphics[scale=0.5]{images/loc_table.png}
      \caption{Statystyka pokrycia kodu testami}
      \label{fig:stat}
    \end{figure}

    Poniżej załączyliśmy diagram (rysunek nr \ref{fig:graph}) obrazujący pokrycie kodu testami w okresie od 10 paździenika do 17 grudnia. Zanotowany duży skok liczby lini kodu w stosunku do testów był spowodowany nadmiarowym umieszczeniem w projekcie biblioteki JavaScript, która nie powinna być wliczana w metrykę.
    Na wykresie widać, że ilość lini kodu oraz testów równomiernie rośnie, co świadczy o systematycznej i dobrze zorganizowanej pracy.
    \begin{figure}[h]
      \centering
      \includegraphics[scale=0.35]{images/LOC.png}
      \caption{Diagram pokrycia kodu testami [12.10-17.12]}
      \label{fig:graph}
    \end{figure}
  \clearpage
